# 管理服务器
管理服务器包含的数据主要包括路由信息、配置信息、租约信息等。

## 路由信息（Rounting Info）
用户可以通过路由信息找到指定复制链对应的所有存储节点，然后可以向任意节点发送读请求，向头节点发送写请求。

路由信息包含三个信息映射表：ChainMap、TargetMap、NodeMap

### 映射表

#### ChainMap   
映射关系：ChainId ——> ChainInfo   
```
struct ChainInfo {
  ChainId chainId;
  ChainVersion chainVersion;
  std::vector<ChainTargetInfo> targets;
}

struct ChainTargetInfo {
  TargetId targetId;
  PublicTargetState publicState;
}
```
ChainTargetInfo 主要是保存 Target 的 Id 和 State，State 指示当前状态，如正常服务、同步、下线等。而 Target 的具体信息保存在 TargetInfo 中。   

#### TargetMap  
映射关系：TargetId ——> TargetInfo   
```
struct TargetInfo {
  TargetId targetId;
  PublicTargetState publicState;
  LocalTargetState localState;
  ChainId chainId;
  std::optional<NodeId> nodeId;
  optional<uint32_t> diskIndex;
  uint64_t usedSize;
};
```
TargetInfo 包含了 Target 所在链的 id —— chainId。  

Target State 分为两部分：  
publicState 是链上服务的状态，状态包括 Serving/Syncing/Offline 等，它表示 storage target 是否能够处理读写请求，对客户端和所有服务都是可见的；  
localState 是本地存储的状态，状态包括 Uptodate/Online/Offline，它只对存储服务和管理服务可见。    

**两种状态的联系**   
存储服务会用 localState 表示本地 storage target 的状态，同时会在心跳消息中携带所有 target 的 localState。管理服务收到心跳消息后，会根据 localState 更改 publicState，然后对外发布 publicState 给客户端或者某个服务，让它们知道当前 target 的服务状态，从而决定是否向 target 发送读/写请求。      

当存储服务的本地存储介质发生故障或被卸载时，会设置对应 target 的 localState 为 offline，然后发送携带 localState 的心跳到管理服务，它会根据 localState 将 publicState 设置为 offline。如果是存储服务发生崩溃，那么管理服务会同时设置 localState 和 publicState 为 offline。   

**举一个简单的状态转换场景**   
假设有一条链，A1-->B1-->C1，A1、B1、C1 分别是节点 A、B、C 的一个 Target。  
1、链上所有 Target 处于正常服务状态：  
A1(Head, PS:Serving, LS:Uptodate) --> B1(PS:Serving, LS:Uptodate) --> C1(Tail, PS:Serving, LS:Uptodate)  
2、节点 C 出现崩溃，C1 Offline：  
A1(Head, PS:Serving, LS:Uptodate) --> B1(Tail, PS:Serving, LS:Uptodate) --> C1(PS:Offline, LS:Offline)  
3、节点 C 恢复后，C1 Online，由于 C1 数据已经落后了，需要向 B1 同步数据：  
A1(Head, PS:Serving, LS:Uptodate) --> B1(Tail, PS:Serving, LS:Uptodate) --> C1(PS:Syncing, LS:Online)  
4、同步完成后，C1 数据是最新的，与集群中的数据保持一致，C1 可以正常服务：  
A1(Head, PS:Serving, LS:Uptodate) --> B1(PS:Serving, LS:Uptodate) --> C1(Tail, PS:Serving, LS:Uptodate)   

注：Uptodate 表示对应 storage target 上的数据已经是最新的，可以对外提供服务。

#### NodeMap   
映射关系：NodeId ——> NodeInfo
```
struct NodeInfo {
  std::vector<net::Address> extractAddresses(const String &serviceName,
    std::optional<net::Address::Type> addressType = std::nullopt) const;
  FbsAppInfo app;
  NodeType type;
  NodeStatus status;
  UtcTime lastHeartbeatTs;
};
```
节点需要指定类型，节点可能是存储服务器、元数据服务器、管理服务器等。   
需要记录最后一次接收到心跳的时间，用于判断节点是否已无法访问。   
通过 extractAddresses() 方法可以获取到节点的通信地址。   

**注**：为了简单描述，路由信息部分省略了 ChainTable 相关的内容，同时对相关结构体进行了简化。   

### 获取块的放置节点
流程：chain -> target -> node
具体步骤：   
用户向管理服务器获取 rountingInfo，缓存到本地；
根据 {indoeId, offset} 本地生成 chainId；
根据 {chainMap, chainId} 获得 targetId；
根据 {targetMap, targetId} 获得 targetInfo，提取nodeId；
根据 {nodeMap, nodeId} 获得 nodeInfo。   

## 配置信息
不同类型的服务器，会对应不同的配置信息。
管理员可以根据类型从管理服务器获取服务器的配置信息。

## 共识协议
租约机制决定领导者。   

待补充。